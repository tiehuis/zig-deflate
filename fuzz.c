// Dumb fuzzer round-trip fuzzing the decompressor in our version against
// streams generated by zlib.

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <inttypes.h>
#include <time.h>
#include <zlib.h>

// points to a static buffer valid till next call
extern int zig_decompress(const uint8_t *input, size_t inlen, uint8_t **output, size_t *outlen);

void print_buffer(const uint8_t *buf, size_t len)
{
    for (size_t i = 0; i < len; ++i) {
        fprintf(stderr, "\\x%02x", buf[i]);
    }
    fprintf(stderr, "\n");
}

int main(void)
{
    srand(time(NULL));

    uint8_t in_buffer[4096];
    uint8_t out_buffer[4096 + 512]; // 0.1% larger plus 12

    uint64_t rounds = 0;

    while (1) {
        if (rounds % 10000 == 0) {
            printf("round: %" PRIu64 "\n", rounds);
        }

        size_t in_len = rand() % sizeof(in_buffer);
        for (size_t i = 0; i < in_len; ++i) {
            in_buffer[i] = rand() & 0xff;
        }

        // level can be between 0-9, choose 0-5 to get a range of different
        // levels but skip the high compression ones.
        int level = rand() % 10;
        size_t out_len = sizeof(out_buffer);
        int r;
        if ((r = compress2(out_buffer, &out_len, in_buffer, in_len, level)) != Z_OK) {
            fprintf(stderr, "bad compress2 (%d)\n", r);
            abort();
        }

        // zig_decompress works purely on a DEFLATE stream where compress2 adds
        // zlib stream headers.
        // Cut these out (2 byte header), (4 byte checksum).

        uint8_t *decomp_output;
        size_t decomp_out_len;
        if ((r = zig_decompress(out_buffer + 2, out_len - 6, &decomp_output, &decomp_out_len)) != 0) {
            fprintf(stderr, "bad zig_decompress (%d)\n", r);
            abort();
        }

        if (decomp_out_len != in_len) {
            fprintf(stderr, "rounds: %"PRIu64 "\n", rounds);
            fprintf(stderr, "decomp len (%zu) not equal to orig len (%zu)\n", decomp_out_len, in_len);

            fprintf(stderr, "\ninput\n");
            print_buffer(in_buffer, in_len);

            fprintf(stderr, "\ncompressed\n");
            print_buffer(out_buffer + 2, out_len - 6);

            fprintf(stderr, "\noutput by zig\n");
            print_buffer(decomp_output, decomp_out_len);
            abort();
        }

        // TODO:
        // eight-byte onwards is getting corrupted somewhere, interface issue
        // not from our implementation?
        if (memcmp(in_buffer, decomp_output, decomp_out_len) != 0) {
            fprintf(stderr, "rounds: %"PRIu64 "\n", rounds);
            fprintf(stderr, "buffers do not match\n");

            fprintf(stderr, "\ninput\n");
            print_buffer(in_buffer, in_len);

            fprintf(stderr, "\ncompressed\n");
            print_buffer(out_buffer + 2, out_len - 6);

            fprintf(stderr, "\noutput by zig\n");
            print_buffer(decomp_output, decomp_out_len);
            abort();
        }

        rounds += 1;
    }
}
